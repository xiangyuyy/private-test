秒杀场景

前端页面缓存

查询缓存

负载处理和并发处理。


一、页面缓存+URL缓存+对象缓存
1、通过加缓存来减少对数据库的访问
2、步骤：
	• 取缓存
	• 手动渲染模版
	• 结果输出
3、页面缓存和URL缓存的过期时间比较短，比较适合变化不大的场景，比如商品列表页。而对象缓存粒度很小，比如通过token来拿到用户
最常用的缓存更新模式Cache Aside Pattern
失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中
命中：应用程序先从cache中取数据，取到后返回
更新：先把数据存到数据库中，成功后，再让缓存失效
二、页面静态化，也就是前后端分离
所有前端页面都是HTML，通过JS、Ajax来访问服务端拿到数据渲染页面。如果只做页面缓存，那么客户端仍然需要到服务端下载页面数据，有了页面静态化之后，这样浏览器就可以将HTML缓存到客户端，页面数据就不需要重复下载了，只需要下载动态的数据就可以了
之前将后端数据放入Model中，前端使用thymeleaf模块来获取后端数据。静态化其实就是采用html+ajax的方式
为防止同一个用户同时秒杀了两个商品，可以为miaosha_order表添加索引，如下

来自 <https://www.cnblogs.com/yanguobin/p/12019307.html> 


三、静态资源优化、CDN优化
1、JS/CSS压缩，减少流量
2、多个JS/CSS组合，减少连接数
3、CDN就近访问，CDN的全称是Content Delivery Network，即内容分发网络

来自 <https://www.cnblogs.com/yanguobin/p/12019307.html> 


延伸问题：

1.redis 集群部署方案。
单机redis 最大连接数1w瓶颈，集群部署3台 *1w = 3w。

连接池的数量并不能决定并发，如果你的 redis 服务处理能力不走，连接建立了，可能并不能处理应用发过来的处理请求。服务器规格有关。

为什么说存储的值不宜过大
比如一个 string key = a，存储了 500MB，首先读取事件压入队列中，文件事件分派器从中获取到后，交于命令请求处理器处理，此处就涉及到从磁盘中加载 500MB。
比如是普通的 SSD 硬盘，读取速度 200MB/S，那么需要 2.5S 的读取时间，在内存中读取数据比较快比如 DDR4 中 50G/秒，读取 500MB 需要 100 毫秒左右。
线程的库一般默认 10 毫秒就算慢查询了，大部分的指令执行时间都是微秒级别，此时其它 socket 所有的请求都将处于等待过程中，就会导致阻塞了 100 毫秒，同时又会占用较大的带宽导致吞吐量进一步下降。

来自 <https://zhuanlan.zhihu.com/p/127056791> 



来自 <https://segmentfault.com/q/1010000021737080/a-1020000021760185> 




2.消息队列的集群部署方案。



