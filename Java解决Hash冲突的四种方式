Java解决Hash冲突的四种方式
开放地址法
即使key产生hash冲突，也不会形成链表，而是将所有元素都存入哈希表里。发生hash冲突时，就以当前地址为基准，进行再寻址的方法去寻址下一个地址，直到找到一个为空的地址为止。实现方式有：
1.线性探测法：发生hash冲突时，顺序查找下一个位置，直到找到一个空位置（固定步长1探测）
2.线性补偿探测法：在发生hash冲突时，在表的左右位置进行按一定步长跳跃式探测（固定步长n探测）
3.伪随机探测：在发生hash冲突时，根据公式生成一个随机数，作为此次探测空位置的步长（随机步长n探测），从而可以避免堆聚
缺点：容易产生堆积问题；不适于大规模的数据存储；散列函数的设计对冲突会有很大的影响；插入时可能会出现多次冲突的现象，删除的元素是多个冲突元素中的一个，需要对后面的元素作处理，实现较复杂；结点规模很大时会浪费很多空间
拉链法
jdk1.8 中HashMap，ConcurrentHashMap都是采用这个方法，使用链表来保存发生hash冲突的key，即不同的key有一样的hash值，将这些发生冲突的 value 组成一个单向链表。
优点：
①拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短
②由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况
③开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间
④在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可
缺点：
指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度
再哈希法
发生hash冲突时，使用第二个，第三个，第四个哈希函数来计算地址，直到无冲突时，比较耗时。
建立公共溢出区
为所有发生hash冲突的关键字记录一个公共的溢出区来存放。在查找的时候，先与哈希表的相应位置比较，如果查找成功，则返回。否则去公共溢出区按顺序查找。在冲突数据少时性能好，冲突数据多的时候耗时。

来自 <https://www.it610.com/article/1298032334943100928.htm> 

